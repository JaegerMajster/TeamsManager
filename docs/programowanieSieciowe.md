# TeamsManager - Programowanie Sieciowe w Praktyce

## üìã Spis tre≈õci
1. [Wprowadzenie](#wprowadzenie)
2. [SignalR - Komunikacja Real-time](#signalr)
3. [REST API - Komunikacja HTTP](#rest-api)
4. [WebSockets - Dwukierunkowa komunikacja](#websockets)
5. [Authentication & Authorization](#authentication)
6. [Local Caching Strategy](#local-caching)
7. [Error Handling & Resilience](#error-handling)
8. [Performance Optimizations](#performance)

---

## üéØ Wprowadzenie {#wprowadzenie}

TeamsManager wykorzystuje **zaawansowany stack technologii sieciowych** do zapewnienia:
- ‚ö° **Real-time komunikacji** (SignalR)
- üåê **RESTful API integration** (HTTP/HTTPS)
- üîê **Enterprise security** (OAuth 2.0)
- üíæ **Offline capabilities** (Local caching)

---

## üîÑ SignalR - Komunikacja Real-time {#signalr}

### **Czym jest SignalR w TeamsManager?**
SignalR umo≈ºliwia **dwukierunkowƒÖ komunikacjƒô w czasie rzeczywistym** miƒôdzy aplikacjƒÖ desktop a serwerem.

### **Implementacja w projekcie:**

#### 1. **SignalR Service Interface**
```csharp
// TeamsManager.UI/Services/SignalRService.cs
public interface ISignalRService
{
    IObservable<object> HealthUpdates { get; }
    IObservable<object> OperationUpdates { get; }
    IObservable<object> MetricsUpdates { get; }
    IObservable<object> AlertUpdates { get; }
    
    Task ConnectAsync();
    Task RequestHealthCheck();
    Task RequestAutoRepair();
}
```

#### 2. **Konfiguracja po≈ÇƒÖczenia SignalR**
```csharp
_hubConnection = new HubConnectionBuilder()
    .WithUrl("https://localhost:5001/monitoringHub", options =>
    {
        options.AccessTokenProvider = async () => 
            await _authService.GetAccessTokenAsync(); // JWT Token
    })
    .WithAutomaticReconnect(new[] { 
        TimeSpan.Zero,           // Natychmiast
        TimeSpan.FromSeconds(2), // Po 2s
        TimeSpan.FromSeconds(10),// Po 10s  
        TimeSpan.FromSeconds(30) // Po 30s
    })
    .Build();
```

#### 3. **Reactive Programming z SignalR**
```csharp
// Rejestracja handler√≥w wiadomo≈õci
_hubConnection.On<object>("HealthUpdate", update =>
{
    _logger.LogDebug("Health update received");
    _healthSubject.OnNext(update); // Reactive stream
});

// Subskrypcja w UI
_signalRService.HealthUpdates
    .ObserveOn(SynchronizationContext.Current) // UI Thread
    .Subscribe(update => UpdateHealthDisplay(update));
```

### **Co to oznacza w praktyce? (dla laika)**

**SignalR w TeamsManager dzia≈Ça jak "natychmiastowy komunikator" miƒôdzy aplikacjƒÖ a serwerem.**

Wyobra≈∫ sobie, ≈ºe Twoja aplikacja to **recepcjonista w hotelu**, a serwer to **kierownik hotelu**:

üè® **Analogia hotelowa:**
```
üìû Zwyk≈Çy telefon (HTTP): 
   Recepcjonista ‚Üí "Dzwoniƒô co 5 minut: Czy sƒÖ jakie≈õ nowe wiadomo≈õci?"
   Kierownik ‚Üí "Nie... nie... nie... TAK, mamy problem w pokoju 205!"

‚ö° SignalR (telefon z natychmiastowymi powiadomieniami):
   Kierownik ‚Üí "NATYCHMIAST: Problem w pokoju 205!" (bez pytania recepcjonisty)
   Recepcjonista ‚Üí "Rozumiem, informujƒô go≈õci!"
```

**W TeamsManager SignalR jest u≈ºywany do:**

1. **üìä Dashboard monitoringu** 
   - *Po ludzku:* Jak tablica wynik√≥w w meczu - aktualizuje siƒô sama, nie musisz od≈õwie≈ºaƒá strony
   - *W praktyce:* Widzisz na ≈ºywo ile operacji siƒô wykonuje, czy system dzia≈Ça sprawnie

2. **üö® Alerty systemowe**
   - *Po ludzku:* Jak sygna≈Ç po≈ºarowy - od razu wiesz, ≈ºe co≈õ siƒô dzieje
   - *W praktyce:* Je≈õli serwer ma problem, aplikacja natychmiast Ci to poka≈ºe

3. **üìà Status operacji** 
   - *Po ludzku:* Jak pasek postƒôpu podczas instalowania programu
   - *W praktyce:* Widzisz na ≈ºywo jak postƒôpuje tworzenie 50 zespo≈Ç√≥w Teams

4. **üîß Naprawy automatyczne**
   - *Po ludzku:* Jak powiadomienie "Problem rozwiƒÖzany automatycznie"
   - *W praktyce:* System naprawi≈Ç b≈ÇƒÖd i od razu Ci o tym m√≥wi

### **Protoko≈Çy pod spodem:**
```
WebSocket (jak hotline) ‚Üí Server-Sent Events ‚Üí Long Polling ‚Üí AJAX Polling (jak ciƒÖg≈Çe dzwonienie)
```

---

## üåê REST API - Komunikacja HTTP {#rest-api}

### **HttpClient Factory Pattern**

#### 1. **Konfiguracja w DI Container**
```csharp
// TeamsManager.UI/App.xaml.cs
services.AddHttpClient("MicrosoftGraph", client =>
{
    client.BaseAddress = new Uri("https://graph.microsoft.com");
    client.DefaultRequestHeaders.Add("User-Agent", "TeamsManager/1.0");
    client.Timeout = TimeSpan.FromSeconds(30);
})
.AddPolicyHandler(GetRetryPolicy())           // Retry przy b≈Çƒôdach
.AddPolicyHandler(GetCircuitBreakerPolicy()); // Circuit breaker

// Default HttpClient
services.AddHttpClient();
```

#### 2. **Retry Policy Configuration**
```csharp
private static IAsyncPolicy<HttpResponseMessage> GetRetryPolicy()
{
    return Policy
        .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
        .Or<HttpRequestException>()
        .WaitAndRetryAsync(
            retryCount: 3,
            sleepDurationProvider: retryAttempt => 
                TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), // Exponential backoff
            onRetry: (outcome, timespan, retryCount, context) =>
            {
                Console.WriteLine($"Retry {retryCount} after {timespan}s");
            });
}
```

### **REST API Endpoints w aplikacji:**

#### 1. **Subjects Management**
```csharp
// TeamsManager.UI/ViewModels/Subjects/SubjectsViewModel.cs

// GET - Pobierz wszystkie przedmioty
var response = await _httpClient.GetAsync("api/v1.0/Subjects");

// POST - Utw√≥rz nowy przedmiot
var content = new StringContent(JsonSerializer.Serialize(dto), Encoding.UTF8, "application/json");
var response = await _httpClient.PostAsync("api/v1.0/Subjects", content);

// PUT - Aktualizuj przedmiot
var response = await _httpClient.PutAsync($"api/v1.0/Subjects/{subject.Id}", content);

// DELETE - Usu≈Ñ przedmiot
var response = await _httpClient.DeleteAsync($"api/v1.0/Subjects/{subject.Id}");
```

#### 2. **Microsoft Graph Integration**
```csharp
// TeamsManager.UI/Services/GraphUserProfileService.cs
public async Task<UserProfile?> GetUserProfileAsync(string accessToken)
{
    var httpClient = _httpClientFactory.CreateClient("MicrosoftGraph");
    httpClient.DefaultRequestHeaders.Authorization = 
        new AuthenticationHeaderValue("Bearer", accessToken);
    
    var response = await httpClient.GetAsync("/v1.0/me");
    if (response.IsSuccessStatusCode)
    {
        var content = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<UserProfile>(content);
    }
    return null;
}
```

### **Co to oznacza w praktyce? (dla laika)**

**REST API w TeamsManager dzia≈Ça jak "kelner w restauracji" - obs≈Çuguje Twoje zam√≥wienia.**

üçΩÔ∏è **Analogia restauracyjna:**

**Ty (aplikacja)** ‚Üí **Kelner (HTTP)** ‚Üí **Kuchnia (serwer/baza danych)**

```
ü•ó GET (Zam√≥w/Pobierz):
   Ty: "Poproszƒô menu przedmiot√≥w"
   Kelner: Idzie do kuchni, wraca z listƒÖ wszystkich przedmiot√≥w
   
üçù POST (Utw√≥rz/Dodaj):
   Ty: "Chcƒô dodaƒá nowy przedmiot: Matematyka zaawansowana"
   Kelner: Zanosi zam√≥wienie do kuchni, wraca z potwierdzeniem
   
üçï PUT (Aktualizuj/Zmie≈Ñ):
   Ty: "Zmie≈Ñ nazwƒô przedmiotu z 'Matematyka' na 'Matematyka podstawowa'"
   Kelner: Przekazuje zmianƒô, wraca z potwierdzeniem
   
üóëÔ∏è DELETE (Usu≈Ñ):
   Ty: "Usu≈Ñ przedmiot 'Fizyka kwantowa'"
   Kelner: Informuje kuchniƒô, wraca z potwierdzeniem usuniƒôcia
```

**W TeamsManager REST API s≈Çu≈ºy do:**

1. **üìö ZarzƒÖdzania przedmiotami**
   - *Po ludzku:* Jak zarzƒÖdzanie ksiƒÖ≈ºkami w bibliotece - dodajesz, usuwasz, zmieniasz
   - *W praktyce:* Klikasz "Dodaj przedmiot" ‚Üí aplikacja wysy≈Ça ≈ºƒÖdanie POST ‚Üí serwer zapisuje w bazie

2. **üë• Integracji z Microsoft 365**
   - *Po ludzku:* Jak ≈ÇƒÖczenie z ksiƒÖ≈ºkƒÖ telefonicznƒÖ firmy Microsoft
   - *W praktyce:* Aplikacja pyta Microsoft Graph: "Podaj mi wszystkich uczni√≥w z klasy 3A"

3. **‚öôÔ∏è Konfiguracji systemu**
   - *Po ludzku:* Jak zmiana ustawie≈Ñ w telefonie
   - *W praktyce:* Zmieniasz ustawienie ‚Üí POST do API ‚Üí zapisane w bazie

### **Dlaczego HttpClient Factory?**
*Po ludzku:* Zamiast zatrudniaƒá nowego kelnera do ka≈ºdego zam√≥wienia, masz **zesp√≥≈Ç kelner√≥w** kt√≥rzy siƒô zmieniajƒÖ, ale zawsze sƒÖ dostƒôpni. To oszczƒôdza czas i pieniƒÖdze.

*Technicznie:* Zamiast tworzyƒá nowe po≈ÇƒÖczenie HTTP do ka≈ºdego ≈ºƒÖdania, u≈ºywamy puli po≈ÇƒÖcze≈Ñ (connection pooling).

### **API Versioning Strategy:**
```
/api/v1.0/[controller]    - "Menu wersja 1.0" (aktualne dania)
/api/v2.0/[controller]    - "Menu wersja 2.0" (nowe dania, stare nadal dostƒôpne)
```
*Po ludzku:* Jak restauracja, kt√≥ra wprowadza nowe menu, ale stare dania nadal mo≈ºna zam√≥wiƒá.

---

## ‚ö° WebSockets - Dwukierunkowa komunikacja {#websockets}

### **WebSocket w kontek≈õcie SignalR:**

#### 1. **Connection State Management**
```csharp
public enum ConnectionState
{
    Disconnected,
    Connecting, 
    Connected,
    Reconnecting,
    Error
}

public ConnectionState ConnectionState 
{ 
    get => _connectionState;
    private set
    {
        if (_connectionState != value)
        {
            _connectionState = value;
            _connectionStateSubject.OnNext(value); // Reactive update
        }
    }
}
```

#### 2. **Event Handlers dla po≈ÇƒÖczenia**
```csharp
// Connection events
_hubConnection.Closed += OnClosed;
_hubConnection.Reconnecting += OnReconnecting;
_hubConnection.Reconnected += OnReconnected;

private Task OnReconnecting(Exception? error)
{
    ConnectionState = ConnectionState.Reconnecting;
    _logger.LogWarning("Connection lost, attempting to reconnect");
    return Task.CompletedTask;
}

private Task OnReconnected(string? connectionId)
{
    ConnectionState = ConnectionState.Connected;
    _logger.LogInformation("Reconnected successfully with ID: {ConnectionId}", connectionId);
    return Task.CompletedTask;
}
```

### **Co to oznacza w praktyce? (dla laika)**

**WebSocket w TeamsManager to jak "otwarta linia telefoniczna" miƒôdzy TobƒÖ a serwerem.**

üìû **Analogia telefoniczna:**

```
üìû Zwyk≈Çy telefon (HTTP):
   Ty: "Cze≈õƒá, jak sprawy?" *roz≈ÇƒÖczasz*
   Za chwilƒô: "Cze≈õƒá, co nowego?" *roz≈ÇƒÖczasz*
   Za chwilƒô: "Cze≈õƒá, wszystko ok?" *roz≈ÇƒÖczasz*
   (Za ka≈ºdym razem wybierasz numer od nowa)

üì± Otwarta linia (WebSocket):
   Ty: "Cze≈õƒá, po≈ÇƒÖczmy siƒô na sta≈Çe"
   Serwer: "Ok, trzymam liniƒô otwartƒÖ"
   Serwer: "A propos, mam dla Ciebie aktualizacjƒô!"
   Ty: "Super, prze≈õlij mi status operacji"
   Serwer: "Ju≈º leci, 50% gotowe... 75%... 100%!"
   (Jedna rozmowa przez ca≈Çy czas)
```

**W TeamsManager WebSocket (przez SignalR) umo≈ºliwia:**

1. **üîÑ DwukierunkowƒÖ komunikacjƒô**
   - *Po ludzku:* Jak rozmowa - obie strony mogƒÖ m√≥wiƒá kiedy chcƒÖ
   - *W praktyce:* Serwer mo≈ºe wys≈Çaƒá alert bez czekania na Twoje pytanie

2. **‚ö° B≈Çyskawiczne aktualizacje**
   - *Po ludzku:* Jak otrzymanie SMS-a - nie musisz sprawdzaƒá skrzynki
   - *W praktyce:* Dashboard aktualizuje siƒô natychmiast gdy co≈õ siƒô zmieni

3. **üí∞ Oszczƒôdno≈õƒá zasob√≥w**
   - *Po ludzku:* Jak taryfa bez limitu zamiast p≈Çacenia za ka≈ºdƒÖ rozmowƒô
   - *W praktyce:* Jedno po≈ÇƒÖczenie zamiast setek ma≈Çych zapyta≈Ñ HTTP

4. **üìä Live monitoring**
   - *Po ludzku:* Jak oglƒÖdanie meczu na ≈ºywo zamiast czytania wynik√≥w nastƒôpnego dnia
   - *W praktyce:* Widzisz na bie≈ºƒÖco co siƒô dzieje z systemem

---

## üîê Authentication & Authorization {#authentication}

### **OAuth 2.0 + Microsoft Authentication Library (MSAL)**

#### 1. **MSAL Configuration**
```csharp
// TeamsManager.UI/Services/MsalAuthService.cs
private IPublicClientApplication CreateMsalApp(MsalConfiguration config)
{
    return PublicClientApplicationBuilder
        .Create(config.AzureAd.ClientId)
        .WithAuthority($"{config.AzureAd.Instance}{config.AzureAd.TenantId}")
        .WithRedirectUri("http://localhost")
        .WithLogging((level, message, containsPii) =>
        {
            _logger.LogDebug("[MSAL] {Message}", message);
        }, LogLevel.Verbose, enablePiiLogging: false)
        .Build();
}
```

#### 2. **Token Acquisition Flow**
```csharp
public async Task<AuthenticationResult?> AcquireTokenInteractiveAsync(Window window)
{
    try
    {
        // Pr√≥ba silent token acquisition
        var accounts = await _app.GetAccountsAsync();
        if (accounts.Any())
        {
            return await _app.AcquireTokenSilent(_scopes, accounts.FirstOrDefault())
                .ExecuteAsync();
        }
        
        // Interactive login
        return await _app.AcquireTokenInteractive(_scopes)
            .WithParentActivityOrWindow(new WindowInteropHelper(window).Handle)
            .ExecuteAsync();
    }
    catch (MsalException ex)
    {
        _logger.LogError(ex, "MSAL authentication failed");
        return null;
    }
}
```

#### 3. **Token-based Authorization**
```csharp
// Dla HTTP requests
httpClient.DefaultRequestHeaders.Authorization = 
    new AuthenticationHeaderValue("Bearer", accessToken);

// Dla SignalR
options.AccessTokenProvider = async () => 
    await _authService.GetAccessTokenAsync();
```

### **Co to oznacza w praktyce? (dla laika)**

**Authentication w TeamsManager dzia≈Ça jak "ochrona na imprezie VIP" - sprawdza kim jeste≈õ i co mo≈ºesz robiƒá.**

üé≠ **Analogia VIP party:**

```
üö™ Wej≈õcie na imprezƒô (OAuth 2.0):
   Ty: "Chcƒô wej≈õƒá na imprezƒô Microsoft 365"
   Ochroniarz: "Poka≈º zaproszenie i dow√≥d osobisty"
   Ty: "Oto m√≥j login i has≈Ço Microsoft"
   Ochroniarz: "OK, oto Twoja opaska VIP" (JWT Token)
   
üè∑Ô∏è Opaska VIP (JWT Token):
   - Zielona opaska = Nauczyciel (mo≈ºesz tworzyƒá zespo≈Çy)
   - Niebieska opaska = Ucze≈Ñ (mo≈ºesz tylko oglƒÖdaƒá)
   - Czerwona opaska = Administrator (mo≈ºesz wszystko)
   
‚è∞ Odnowienie opaski:
   Po godzinie opaska "ga≈õnie" - trzeba i≈õƒá do ochroniarza po nowƒÖ
   Ale aplikacja robi to automatycznie, Ty tego nie widzisz
```

**W TeamsManager uwierzytelnianie s≈Çu≈ºy do:**

1. **üîê Logowania do Microsoft 365**
   - *Po ludzku:* Jak u≈ºywanie karty do bankomatu - bank sprawdza czy to Ty
   - *W praktyce:* Wpisujesz has≈Ço Microsoft raz, aplikacja dostaje "kartƒô dostƒôpu" na godzinƒô

2. **üé´ Kontroli uprawnie≈Ñ**
   - *Po ludzku:* Jak r√≥≈ºne rodzaje bilet√≥w w kinie - VIP, standard, dzieci
   - *W praktyce:* Dyrektor widzi wszystko, nauczyciel widzi swoje klasy, ucze≈Ñ widzi swoje zespo≈Çy

3. **üîÑ Automatycznego odnawiania**
   - *Po ludzku:* Jak automatyczne przed≈Çu≈ºanie abonamentu Netflix
   - *W praktyce:* Co godzinƒô aplikacja cicho odnawia dostƒôp, Ty nic nie robisz

4. **üõ°Ô∏è Bezpiecznego przechowywania**
   - *Po ludzku:* Jak sejf w banku na cenne rzeczy
   - *W praktyce:* Windows bezpiecznie przechowuje Twoje tokeny, inne programy ich nie widzƒÖ

### **Security Features (wyja≈õnienie dla laika):**
- üé´ **JWT Tokens** - "elektroniczne opaski VIP" z datƒÖ wa≈ºno≈õci
- üîÑ **Token refresh** - "automatyczny przed≈Çu≈ºacz abonamenty"
- üîê **Secure storage** - "cyfrowy sejf Windows" na has≈Ça
- üõ°Ô∏è **Multi-factor auth** - "podw√≥jne sprawdzenie to≈ºsamo≈õci" (has≈Ço + SMS)

---

## üíæ Local Caching Strategy {#local-caching}

### **SQLite jako Local Cache**

#### 1. **Database Configuration**
```csharp
// TeamsManager.UI/App.xaml.cs
private string GetDatabaseConnectionString(IConfiguration configuration)
{
    // Bezpieczna lokalizacja w AppData
    var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
    var appFolderPath = Path.Combine(appDataPath, "TeamsManager");
    var dbPath = Path.Combine(appFolderPath, "teamsmanager.db");
    
    return $"Data Source={dbPath}";
}
```

#### 2. **Cache-Aside Pattern**
```csharp
// TeamsManager.UI/Services/SimpleUserService.cs
public async Task<IEnumerable<User>> GetAllActiveUsersAsync(bool forceRefresh = false)
{
    try
    {
        // Sprawd≈∫ po≈ÇƒÖczenie z bazƒÖ
        if (!await _context.Database.CanConnectAsync())
        {
            throw new InvalidOperationException("Brak po≈ÇƒÖczenia z bazƒÖ danych");
        }

        var query = _context.Users.Include(u => u.Department).AsQueryable();
        query = query.Where(u => u.IsActive);
        
        var users = await query.ToListAsync();
        _logger.LogInformation("Znaleziono {Count} u≈ºytkownik√≥w", users.Count);
        
        return users;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "B≈ÇƒÖd podczas pobierania u≈ºytkownik√≥w");
        throw;
    }
}
```

### **Co to oznacza w praktyce? (dla laika)**

**Local Caching w TeamsManager dzia≈Ça jak "notatnik z czƒôsto u≈ºywanymi numerami telefon√≥w".**

üìí **Analogia notatnika:**

```
üè† Bez notatnika (bez cache):
   Chcesz zadzwoniƒá do pizzerii ‚Üí Szukasz w ksiƒÖ≈ºce telefonicznej ‚Üí Dzwonisz
   Znowu chcesz zadzwoniƒá ‚Üí Znowu szukasz w ksiƒÖ≈ºce ‚Üí Dzwonisz
   (Za ka≈ºdym razem przeszukujesz ca≈ÇƒÖ ksiƒÖ≈ºkƒô)

üìù Z notatnikiem (z cache):
   Pierwszy raz: Szukasz w ksiƒÖ≈ºce ‚Üí Zapisujesz w notatniku ‚Üí Dzwonisz  
   Nastƒôpny raz: Patrzysz w notatnik ‚Üí Od razu dzwonisz
   (Szybko, bo masz pod rƒôkƒÖ)
   
üîÑ Aktualizacja notatnika:
   Co jaki≈õ czas sprawdzasz czy numery siƒô nie zmieni≈Çy
   Je≈õli tak - poprawiasz w notatniku
```

**W TeamsManager local cache (SQLite) s≈Çu≈ºy do:**

1. **‚ö° Szybkiego dostƒôpu do danych**
   - *Po ludzku:* Jak ulubione kontakty w telefonie - masz je pod rƒôkƒÖ
   - *W praktyce:* Lista u≈ºytkownik√≥w ≈Çaduje siƒô b≈Çyskawicznie bo jest zapisana lokalnie

2. **üì± Pracy offline**
   - *Po ludzku:* Jak fotokopia dokumentu - mo≈ºesz jƒÖ czytaƒá nawet gdy orygina≈Ç jest daleko
   - *W praktyce:* Mo≈ºesz przeglƒÖdaƒá u≈ºytkownik√≥w nawet bez internetu

3. **üí∞ Oszczƒôdno≈õci transferu**
   - *Po ludzku:* Jak kserowania czƒôsto u≈ºywanych dokument√≥w zamiast chodzenia do archiwum
   - *W praktyce:* Aplikacja nie musi ciƒÖgle pobieraƒá tych samych danych z internetu

4. **üîÑ Inteligentnego od≈õwie≈ºania**
   - *Po ludzku:* Jak sprawdzanie czy co≈õ siƒô zmieni≈Ço przed aktualizacjƒÖ notatnika
   - *W praktyce:* Cache siƒô aktualizuje tylko gdy trzeba, nie ca≈Çy czas

### **Caching Strategy (dla laika):**
- üìä **Cache-first** - "sprawd≈∫ notatnik przed siƒôgniƒôciem po ksiƒÖ≈ºkƒô telefonicznƒÖ"
- üîÑ **Lazy loading** - "za≈Çaduj tylko to czego potrzebujesz teraz"
- ‚è∞ **TTL** - "przepisz notatnik co tydzie≈Ñ ≈ºeby by≈Ç aktualny"
- üíæ **Offline mode** - "u≈ºywaj notatnika nawet gdy biblioteka jest zamkniƒôta"

---

## üõ°Ô∏è Error Handling & Resilience {#error-handling}

### **1. Circuit Breaker Pattern**
```csharp
private static IAsyncPolicy<HttpResponseMessage> GetCircuitBreakerPolicy()
{
    return Policy
        .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
        .CircuitBreakerAsync(
            handledEventsAllowedBeforeBreaking: 3,
            durationOfBreak: TimeSpan.FromSeconds(30),
            onBreak: (exception, timespan) =>
            {
                Console.WriteLine($"Circuit breaker opened for {timespan}");
            },
            onReset: () =>
            {
                Console.WriteLine("Circuit breaker closed");
            });
}
```

### **2. Exponential Backoff**
```csharp
// Automatyczne retry z rosnƒÖcymi op√≥≈∫nieniami
.WaitAndRetryAsync(
    retryCount: 3,
    sleepDurationProvider: retryAttempt => 
        TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) // 2s, 4s, 8s
);
```

### **Co to oznacza w praktyce? (dla laika)**

**Error Handling w TeamsManager dzia≈Ça jak "system zapas√≥w w firmie kurierskiej".**

üì¶ **Analogia firmy kurierskiej:**

```
üöö Circuit Breaker (wy≈ÇƒÖcznik obwodu):
   Droga g≈Ç√≥wna: "Dorƒôczamy paczki normalnie"
   Korek na drodze: "Za du≈ºo problem√≥w - zamykamy drogƒô na 30 minut"
   Po 30 minutach: "Sprawdzamy czy droga jest przejezdna"
   Je≈õli OK: "Otwieramy drogƒô z powrotem"
   
üîÑ Retry (ponowne pr√≥by):
   Kuriera: "Nie zasta≈Çem - spr√≥bujƒô za 2 minuty"
   Je≈õli znowu nie: "Spr√≥bujƒô za 4 minuty"  
   Je≈õli znowu nie: "Spr√≥bujƒô za 8 minut"
   Po 3 pr√≥bach: "Oddajƒô paczkƒô do magazynu"
   
üõ°Ô∏è Graceful Degradation (≈Çagodna degradacja):
   Plan A: "Dorƒôczam z g≈Ç√≥wnego magazynu"
   Magazyn zamkniƒôty: "OK, sprawdzam lokalny punkt"
   I tam pusta: "Informujƒô klienta: 'Dorƒôczƒô jutro'"
```

**W TeamsManager error handling chroni przed:**

1. **üîÑ Circuit Breaker - blokada przeciƒÖ≈ºonego serwera**
   - *Po ludzku:* Jak automatyczna blokada karty kredytowej po podejrzanych transakcjach
   - *W praktyce:* Je≈õli API Microsoft zwraca 3 b≈Çƒôdy pod rzƒÖd, aplikacja przestaje pytaƒá na 30 sekund

2. **‚ö° Retry - automatyczne ponawianie**
   - *Po ludzku:* Jak ponawianie dzwonienia gdy linia jest zajƒôta
   - *W praktyce:* Nie uda≈Ço siƒô pobraƒá u≈ºytkownik√≥w? Spr√≥buj ponownie za 2s, 4s, 8s

3. **üõ°Ô∏è Graceful Degradation - ≈Çagodne awariƒô**
   - *Po ludzku:* Jak u≈ºywanie latarki gdy zga≈õnie ≈õwiat≈Ço zamiast siedzenia w ciemno≈õci
   - *W praktyce:* Nie ma internetu? Poka≈º dane z lokalnej cache zamiast b≈Çƒôdu

### **3. Graceful Degradation (wyja≈õnienie dla laika)**
```csharp
// To jest jak "plan B" w aplikacji
public async Task<IEnumerable<User>> GetUsersWithFallback()
{
    try
    {
        // Plan A: Pobierz ≈õwie≈ºe dane z internetu
        return await GetUsersFromApi();
    }
    catch (HttpRequestException)
    {
        // Plan B: U≈ºyj danych z lokalnej cache
        return await GetUsersFromCache();
    }
}
```
*Po ludzku:* "Je≈õli nie mogƒô dostaƒá ≈õwie≈ºej pizzy, dam Ci wczorajszƒÖ z lod√≥wki - lepsze to ni≈º nic!"

---

## ‚ö° Performance Optimizations {#performance}

### **1. Connection Pooling**
```csharp
// HttpClient factory automatycznie zarzƒÖdza poolingiem po≈ÇƒÖcze≈Ñ
services.AddHttpClient("MicrosoftGraph")
    .ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler()
    {
        MaxConnectionsPerServer = 10,
        PooledConnectionLifetime = TimeSpan.FromMinutes(15)
    });
```

### **2. Asynchronous Operations**
```csharp
// Parallel API calls
var departmentsTask = LoadDepartmentsAsync();
var usersTask = LoadUsersAsync(forceRefresh: true);

await Task.WhenAll(departmentsTask, usersTask);
```

### **3. Reactive Streams**
```csharp
// Throttling dla UI updates
_signalRService.MetricsUpdates
    .Throttle(TimeSpan.FromMilliseconds(500)) // Max 2 updates per second
    .ObserveOn(SynchronizationContext.Current)
    .Subscribe(UpdateMetricsDisplay);
```

### **Co to oznacza w praktyce? (dla laika)**

**Performance Optimizations w TeamsManager to jak "dobrze zorganizowana kuchnia w restauracji".**

üç≥ **Analogia kuchni restauracyjnej:**

```
üë• Connection Pooling (pula kelner√≥w):
   ≈πle: Zatrudniasz nowego kelnera do ka≈ºdego stolika
   Dobrze: Masz zesp√≥≈Ç kelner√≥w, kt√≥rzy obs≈ÇugujƒÖ wszystkie stoliki
   
‚ö° Asynchronous Operations (r√≥wnoczesne gotowanie):
   ≈πle: Gotujesz danie po daniu - zupa, potem drugie, potem deser
   Dobrze: Zupa siƒô gotuje, drugie na patelni, deser w piekarniku - wszystko naraz
   
üéõÔ∏è Throttling (kontrola tempa):
   ≈πle: Kelner biegnie do kuchni za ka≈ºdym k≈Çapniƒôciem oka go≈õcia
   Dobrze: Kelner idzie do kuchni max raz na 30 sekund, zbiera wszystkie zam√≥wienia
   
üßπ Memory Management (sprzƒÖtanie):
   ≈πle: Zostawiasz brudne naczynia na ca≈ÇƒÖ noc
   Dobrze: Myjesz naczynia po ka≈ºdym u≈ºyciu
```

**W TeamsManager optymalizacje pomagajƒÖ:**

1. **üë• Connection Pooling - pula po≈ÇƒÖcze≈Ñ**
   - *Po ludzku:* Jak udostƒôpnianie samochod√≥w zamiast kupowania nowego do ka≈ºdej podr√≥≈ºy
   - *W praktyce:* Aplikacja u≈ºywa tych samych po≈ÇƒÖcze≈Ñ HTTP zamiast tworzenia nowych

2. **‚ö° Asynchronous Operations - r√≥wnoczesne operacje**
   - *Po ludzku:* Jak pranie w pralce podczas gotowania - robisz dwie rzeczy naraz
   - *W praktyce:* Aplikacja ≈Çaduje u≈ºytkownik√≥w i dzia≈Çy jednocze≈õnie, nie kolejno

3. **üéõÔ∏è Throttling - ograniczanie czƒôstotliwo≈õci**
   - *Po ludzku:* Jak ograniczenie "max 3 pytania na minutƒô" ≈ºeby nie zawracaƒá g≈Çowy
   - *W praktyce:* Dashboard aktualizuje siƒô max 2 razy na sekundƒô, nie 50 razy

### **4. Memory Management (zarzƒÖdzanie pamiƒôciƒÖ dla laika)**
```csharp
// To jak sprzƒÖtanie po sobie
public void Dispose()
{
    try
    {
        _hubConnection?.DisposeAsync();    // Roz≈ÇƒÖcz telefon
        _healthSubject?.Dispose();         // Wyrzuƒá stare notatki  
        _operationSubject?.Dispose();      // Zamknij wszystkie pliki
        _metricsSubject?.Dispose();        // Wyczy≈õƒá tablicƒô
        _alertSubject?.Dispose();          // Wy≈ÇƒÖcz alarmy
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "B≈ÇƒÖd podczas sprzƒÖtania");
    }
}
```
*Po ludzku:* "Po sko≈Ñczonej pracy zamykam wszystkie programy, wy≈ÇƒÖczam ≈õwiat≈Ço i zamykam drzwi na klucz"

---

## üìä **Podsumowanie Technologii**

| **Warstwa** | **Technologia** | **Zastosowanie w TeamsManager** |
|-------------|-----------------|--------------------------------|
| **Real-time** | SignalR + WebSocket | Monitoring, alerts, live updates |
| **HTTP API** | HttpClient + REST | CRUD operations, Graph/Teams integration |
| **Security** | OAuth 2.0 + MSAL | Authentication, authorization |
| **Caching** | SQLite + EF Core | Local storage, offline mode |
| **Resilience** | Polly policies | Retry, circuit breaker, timeout |

---

## üéØ **PODSUMOWANIE DLA LAIKA**

### **TeamsManager to jak dobrze zorganizowany "centralny system komunikacji w szkole":**

üè´ **Wyobra≈∫ sobie szko≈Çƒô przysz≈Ço≈õci:**

```
üì± Twoja aplikacja = Inteligentny asystent dyrektora
üì° SignalR = Interkom szkolny (natychmiastowe og≈Çoszenia)  
üåê REST API = System pocztowy (wysy≈Çanie i odbieranie dokument√≥w)
üîê OAuth 2.0 = Elektroniczna przepustka (kontrola dostƒôpu)
üíæ SQLite = Szkolna kartoteka (lokalne kopie dokument√≥w)
üõ°Ô∏è Error Handling = System zapasowy (plany B, C, D)
```

### **Co dzieje siƒô gdy u≈ºywasz TeamsManager:**

**1. üîê Logujesz siƒô (OAuth 2.0)**
- *Jak:* Pokazujesz przepustkƒô ochroniarzowi
- *W praktyce:* Microsoft sprawdza TwojƒÖ to≈ºsamo≈õƒá i daje "klucz cyfrowy"

**2. üìä Otwierasz dashboard (SignalR)**  
- *Jak:* W≈ÇƒÖczasz interkom szkolny na nas≈Çuch
- *W praktyce:* Aplikacja otwiera "gorƒÖcƒÖ liniƒô" z serwerem na ≈ºywe aktualizacje

**3. üë• PrzeglƒÖdasz u≈ºytkownik√≥w (REST API + Cache)**
- *Jak:* Sprawdzasz lokalnƒÖ kartotekƒô, potem dzwonisz po aktualizacje
- *W praktyce:* Aplikacja pokazuje dane z lokalnej bazy, w tle sprawdza czy sƒÖ nowsze

**4. üö® Dostajesz alert (SignalR + WebSocket)**
- *Jak:* S≈Çyszysz og≈Çoszenie przez interkom: "Uwaga, problem w klasie 3A!"
- *W praktyce:* Serwer natychmiast wysy≈Ça powiadomienie o b≈Çƒôdzie

**5. üìù Tworzysz nowy zesp√≥≈Ç (REST API)**
- *Jak:* Wype≈Çniasz formularz i wysy≈Çasz pocztƒÖ do sekretariatu
- *W praktyce:* POST do API Microsoft Teams ‚Üí nowy zesp√≥≈Ç utworzony

### **Dlaczego to wszystko jest takie skomplikowane?**

ü§î **Bo to jak zarzƒÖdzanie wielkim przedsiƒôbiorstwem:**

- **üõ°Ô∏è Bezpiecze≈Ñstwo** - Nie ka≈ºdy mo≈ºe mieƒá dostƒôp do wszystkiego  
- **‚ö° Wydajno≈õƒá** - TysiƒÖce u≈ºytkownik√≥w naraz, musi dzia≈Çaƒá szybko
- **üîÑ Niezawodno≈õƒá** - Je≈õli co≈õ siƒô psuje, musi byƒá plan B
- **üìä Skalowalno≈õƒá** - Musi dzia≈Çaƒá dla 10 jak i 10,000 u≈ºytkownik√≥w

### **üéØ Kluczowe zalety (po ludzku):**
- ‚ö° **Szybko≈õƒá** - jak mieƒá ulubione kontakty pod rƒôkƒÖ
- üõ°Ô∏è **Odporno≈õƒá** - jak mieƒá 3 r√≥≈ºne drogi do domu  
- üîê **Bezpiecze≈Ñstwo** - jak elektroniczny zamek zamiast zwyk≈Çego klucza
- üîÑ **Na ≈ºywo** - jak oglƒÖdanie meczu live zamiast powt√≥rki
- üì± **Wygoda** - jak dobry asystent kt√≥ry pamiƒôta wszystko za Ciebie

**TeamsManager to zaawansowana "cyfrowa recepcja" Twojej szko≈Çy, kt√≥ra ≈ÇƒÖczy siƒô z Microsoft 365 i wszystko robi za Ciebie - szybko, bezpiecznie i niezawodnie!** üöÄ

---

*Dokument utworzony na podstawie rzeczywistej implementacji TeamsManager - wszystkie przyk≈Çady kodu pochodzƒÖ z dzia≈ÇajƒÖcej aplikacji.* üìö 