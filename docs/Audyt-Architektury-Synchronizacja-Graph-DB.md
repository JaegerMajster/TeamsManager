# Audyt Architektury - Synchronizacja Graph-DB (Etap 1/8)

**Data audytu:** 2024-12-19  
**Ga≈ÇƒÖ≈∫:** `refaktoryzacja`  
**Cel:** Zmapowanie istniejƒÖcych mechanizm√≥w przed implementacjƒÖ synchronizacji Graph‚ÜîDB  

---

## 1. Analiza wywo≈Ça≈Ñ PowerShell

### Serwisy u≈ºywajƒÖce rƒôcznego ConnectWithAccessTokenAsync:
- **UserService**: 2 wystƒÖpienia ‚úÖ
  - Lokalizacje: `CreateUserAsync` (linia 267), `ActivateUserAsync` (linia 1351)
  - Wzorzec: bezpo≈õrednie sprawdzenie `if (!await _powerShellService.ConnectWithAccessTokenAsync(apiAccessToken))`
  
- **TeamService**: 5 wystƒÖpie≈Ñ ‚úÖ
  - Lokalizacje: `CreateTeamAsync` (323), `UpdateTeamAsync`, `ArchiveTeamAsync` (653), `DeleteTeamAsync` (875), `AddUsersToTeamAsync` (1252), `RemoveUsersFromTeamAsync` (1427)
  - Wzorzec: identyczny jak UserService - sprawdzenie sukcesu po≈ÇƒÖczenia

### Serwisy u≈ºywajƒÖce ExecuteWithAutoConnectAsync:
- **ChannelService**: 3 wystƒÖpienia ‚úÖ **KONSEKWENTNE U≈ªYCIE**
  - `GetTeamChannelsAsync`: linia 149 - pe≈Çna synchronizacja z Graph
  - `GetTeamChannelByIdAsync`: linia 264 - pojedynczy kana≈Ç
  - `CreateTeamChannelAsync`, `UpdateTeamChannelAsync`: operacje CRUD
  
- **UserService**: 2 wystƒÖpienia w testach ‚úÖ
  - `CreateUserAsync` z ExecuteWithAutoConnectAsync
  - `UpdateUserAsync` z ExecuteWithAutoConnectAsync

- **PowerShellService**: Definiuje metodƒô ‚úÖ
  - Implementacja w `PowerShellService.cs` linia 100
  - Obs≈Çuguje OBO flow przez TokenManager

### ‚ö†Ô∏è ODKRYCIA KRYTYCZNE:
1. **NIESP√ìJNO≈öƒÜ W PODEJ≈öCIU**: Niekt√≥re serwisy u≈ºywajƒÖ rƒôcznego `ConnectWithAccessTokenAsync`, inne `ExecuteWithAutoConnectAsync`
2. **ChannelService jako WZORZEC**: Jedyny serwis konsekwentnie u≈ºywajƒÖcy `ExecuteWithAutoConnectAsync`
3. **BEZPO≈öREDNIE PO≈ÅƒÑCZENIA W TEAMSERVICE**: Wszystkie operacje CRUD u≈ºywajƒÖ rƒôcznego po≈ÇƒÖczenia

---

## 2. IstniejƒÖce mechanizmy synchronizacji

### ‚úÖ ZNALEZIONE - PE≈ÅNA SYNCHRONIZACJA:
#### **ChannelService.MapPsObjectToLocalChannel** ‚≠ê **WZORZEC DO NA≈öLADOWANIA**
```55:128:TeamsManager.Core/Services/ChannelService.cs
private Channel MapPsObjectToLocalChannel(PSObject psChannel, string localTeamId)
{
    var graphChannelId = PSObjectMapper.GetString(psChannel, "id") ?? Guid.NewGuid().ToString();
    var channel = new Channel
    {
        Id = graphChannelId,
        TeamId = localTeamId,
        DisplayName = PSObjectMapper.GetString(psChannel, "displayName") ?? "Nieznany Kana≈Ç",
        Description = PSObjectMapper.GetString(psChannel, "description"),
        ChannelType = PSObjectMapper.GetString(psChannel, "membershipType") ?? "Standard",
        // ... pe≈Çne mapowanie wszystkich w≈Ça≈õciwo≈õci
    };
    // Walidacja biznesowa i logika
    return channel;
}
```

#### **ChannelService.GetTeamChannelsAsync** ‚≠ê **KOMPLETNA SYNCHRONIZACJA**
```139:238:TeamsManager.Core/Services/ChannelService.cs
// Synchronizacja kana≈Ç√≥w z Graph do lokalnej bazy
var graphChannelIds = new HashSet<string>(channelsFromGraph.Select(c => c.Id));

foreach (var graphChannel in channelsFromGraph)
{
    var localChannel = localChannels.FirstOrDefault(lc => lc.Id == graphChannel.Id);
    if (localChannel == null)
    {
        // DODANIE NOWEGO
        graphChannel.CreatedBy = currentUser;
        await _channelRepository.AddAsync(graphChannel);
    }
    else
    {
        // AKTUALIZACJA ISTNIEJƒÑCEGO - pe≈Çna synchronizacja p√≥l
        bool updated = false;
        if (localChannel.DisplayName != graphChannel.DisplayName) { /* aktualizacja */ }
        // ... wszystkie pola
        if (updated) {
            localChannel.MarkAsModified(currentUser);
            _channelRepository.Update(localChannel);
        }
    }
}

// OZNACZANIE USUNIƒòTYCH
foreach (var localChannel in localChannels.Where(lc => lc.Status == ChannelStatus.Active))
{
    if (!graphChannelIds.Contains(localChannel.Id))
    {
        localChannel.Archive($"Kana≈Ç usuniƒôty z Microsoft Teams", currentUser);
        _channelRepository.Update(localChannel);
    }
}
```

### ‚ùå BRAK SYNCHRONIZACJI:
#### **TeamService.GetTeamByIdAsync** ‚ö†Ô∏è **KOMENTARZ O BRAKU IMPLEMENTACJI**
```128:131:TeamsManager.Core/Services/TeamService.cs
var psTeam = await _powerShellTeamService.GetTeamAsync(teamId);
if (psTeam != null)
{
    _logger.LogDebug("Zesp√≥≈Ç ID: {TeamId} znaleziony w Graph API. Synchronizacja z lokalnƒÖ bazƒÖ (niezaimplementowana).", teamId);
}
```

#### **UserService** ‚ùå **BRAK PR√ìB SYNCHRONIZACJI**
- ≈ªadna metoda nie pr√≥buje synchronizowaƒá danych u≈ºytkownika z Graph przy pobieraniu
- Operacje CRUD idƒÖ tylko w jednƒÖ stronƒô: Local‚ÜíGraph

---

## 3. U≈ºycie cache

### ‚ö†Ô∏è PODW√ìJNE PODEJ≈öCIE - PROBLEM DO ROZWIƒÑZANIA:
#### **ChannelService** - MIESZANE U≈ªYCIE:
```30:31,56:57:TeamsManager.Core/Services/ChannelService.cs
private readonly IMemoryCache _cache;
private readonly IPowerShellCacheService _powerShellCacheService;

private MemoryCacheEntryOptions GetDefaultCacheEntryOptions()
{
    return _powerShellCacheService.GetDefaultCacheEntryOptions();
}
```
- **PROBLEM**: U≈ºywa IMemoryCache do przechowywania ale IPowerShellCacheService do konfiguracji
- **NIEBEZPIECZE≈ÉSTWO**: R√≥≈ºne mechanizmy invalidacji

### Tylko IMemoryCache:
1. **DepartmentService** ‚úÖ + delegacja do PowerShellCacheService
2. **SubjectService** ‚úÖ + delegacja do PowerShellCacheService  
3. **SchoolYearService** ‚úÖ + delegacja do PowerShellCacheService
4. **TeamTemplateService** ‚úÖ + delegacja do PowerShellCacheService
5. **ApplicationSettingService** ‚úÖ u≈ºywa tylko IPowerShellCacheService

### Tylko IPowerShellCacheService:
1. **TeamService** ‚úÖ **KONSEKWENTNE U≈ªYCIE**
2. **UserService** ‚úÖ **KONSEKWENTNE U≈ªYCIE**
3. **PowerShellCacheService** ‚úÖ **G≈Å√ìWNY SERWIS**

### ‚úÖ DOBRY WZORZEC - Delegacja:
```59:63:TeamsManager.Core/Services/DepartmentService.cs
private MemoryCacheEntryOptions GetDefaultCacheEntryOptions()
{
    return _powerShellCacheService.GetDefaultCacheEntryOptions();
}
```

---

## 4. Wzorce transakcyjne

### ‚ùå NIE ZNALEZIONO SaveChangesAsync w serwisach:
- **BRAK** bezpo≈õrednich wywo≈Ça≈Ñ `SaveChangesAsync()` w warstwie serwis√≥w
- **ZNALEZIONO** komentarz: `// SaveChangesAsync na wy≈ºszym poziomie` w ChannelService
- **BRAK** implementacji Unit of Work pattern

### ‚úÖ ZNALEZIONO SaveChangesAsync w DbContext:
```531:537:TeamsManager.Data/TeamsManagerDbContext.cs
public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
{
    SetAuditFields();
    return await base.SaveChangesAsync(cancellationToken);
}
```

### Miejsca wymagajƒÖce transakcji:
1. **Operacje bulk w TeamService** - AddUsers/RemoveUsers
2. **Tworzenie zespo≈Çu z cz≈Çonkami** - wieloetapowe operacje
3. **Synchronizacja z Graph** - wiele aktualizacji jednocze≈õnie
4. **ChannelService synchronizacja** - Add/Update/Archive w jednej operacji

---

## 5. PowerShellCacheService - mo≈ºliwo≈õci

### ‚úÖ IstniejƒÖce funkcje podstawowe:
```20:60:TeamsManager.Core/Abstractions/Services/PowerShell/IPowerShellCacheService.cs
Task<string?> GetUserIdAsync(string userUpn, bool forceRefresh = false);
void SetUserId(string userUpn, string userId);
bool TryGetValue<T>(string key, out T? value);
void Set<T>(string key, T value, TimeSpan? duration = null);
void Remove(string key);
```

### ‚úÖ Funkcje invalidacji:
```53:85:TeamsManager.Core/Abstractions/Services/PowerShell/IPowerShellCacheService.cs
void InvalidateUserCache(string? userId = null, string? userUpn = null);
void InvalidateTeamCache(string teamId);
void InvalidateAllCache();
void InvalidateChannelsForTeam(string teamId);
void InvalidateChannel(string channelId);
void InvalidateChannelAndTeam(string teamId, string channelId);
void InvalidateDepartment(string departmentId);
```

### ‚úÖ Funkcje P2 (ju≈º zaimplementowane!):
```631:741:TeamsManager.Core/Services/PowerShell/PowerShellCacheService.cs
// [P2-OPTIMIZATION] Smart cache warming
public async Task WarmCacheAsync(string cacheKey, Func<Task<object>> dataLoader, TimeSpan? duration = null)

// [P2-OPTIMIZATION] Pagination support
public bool TryGetPagedValue<T>(string baseCacheKey, int pageNumber, int pageSize, out T? value)
public void SetPagedValue<T>(string baseCacheKey, int pageNumber, int pageSize, T value, TimeSpan? duration = null)

// [P2-OPTIMIZATION] Smart pattern-based invalidation
public void InvalidateByPattern(string pattern, string operationName = "PatternInvalidation")

// [P2-OPTIMIZATION] Batch invalidation to reduce cache stampedes
public void BatchInvalidateKeys(IEnumerable<string> cacheKeys, string operationName = "BatchInvalidation")

// [P2-MONITORING] Cache metrics and performance tracking
public CacheMetrics GetCacheMetrics()
private void RecordCacheOperation(string operationName, long durationMs, int itemCount = 1)
```

### ‚ùå BrakujƒÖce funkcje:
- Brak hierarchicznych kluczy cache (team.channels.*)
- Brak automatycznej invalidacji po synchronizacji Graph‚ÜíDB

---

## 6. Potencjalne konflikty

### üî¥ WYSOKIE RYZYKO:
#### **PowerShellCacheService ma ju≈º rozszerzone funkcje P2**
- ‚ùå **NIE DUPLIKUJ** `BatchInvalidateKeys` - ju≈º istnieje
- ‚ùå **NIE DUPLIKUJ** `GetCacheMetrics` - ju≈º zaimplementowane  
- ‚ùå **NIE DUPLIKUJ** `WarmCacheAsync` - ju≈º dzia≈Ça
- ‚ùå **NIE DUPLIKUJ** `InvalidateByPattern` - ju≈º gotowe

#### **ChannelService ma pe≈ÇnƒÖ synchronizacjƒô Graph‚ÜíDB**
- ‚úÖ **U≈ªYJ JAKO WZORZEC** - nie reimplementuj
- ‚úÖ **ROZSZERZ NA INNE SERWISY** - TeamService, UserService

### üü° ≈öREDNIE RYZYKO:
#### **Mieszane u≈ºycie cache** - ChannelService
- **WYMAGA UJEDNOLICENIA** przed refaktoryzacjƒÖ
- Albo pe≈Çny IMemoryCache, albo pe≈Çny IPowerShellCacheService

#### **Brak Unit of Work** 
- **MO≈ªE WYMAGAƒÜ ZMIAN W KONTROLERACH**
- Obecnie SaveChangesAsync wywo≈Çywane na poziomie kontrolera/repozytorium

### üü¢ NISKIE RYZYKO:
#### **Niesp√≥jno≈õƒá ExecuteWithAutoConnectAsync vs ConnectWithAccessTokenAsync**
- ≈Åatwe do zunifikowania - u≈ºyj ExecuteWithAutoConnectAsync wszƒôdzie

---

## 7. Rekomendacje dla nastƒôpnych etap√≥w

### ‚ùå NIE IMPLEMENTUJ (ju≈º istnieje):
1. **Mapowania PSObject** - u≈ºyj wzorca `MapPsObjectToLocalChannel`
2. **Rozszerzonych funkcji cache** - P2 funkcje ju≈º sƒÖ w PowerShellCacheService  
3. **Batch invalidation** - `BatchInvalidateKeys` ju≈º dzia≈Ça
4. **Cache metrics** - `GetCacheMetrics` ju≈º zaimplementowane
5. **Pattern invalidation** - `InvalidateByPattern` ju≈º istnieje

### ‚úÖ ZAIMPLEMENTUJ (brakuje):
1. **Synchronizacjƒô w TeamService** - brak mapowania PSTeam‚ÜíTeam
2. **Synchronizacjƒô w UserService** - brak Graph‚ÜíDB sync
3. **Unit of Work pattern** - obecnie brak transakcji
4. **Sp√≥jne u≈ºycie ExecuteWithAutoConnectAsync** - czƒô≈õƒá serwis√≥w u≈ºywa rƒôcznego ConnectWithAccessTokenAsync
5. **Ujednolicenie cache** - ChannelService ma mixed approach

### ‚ö†Ô∏è ZACHOWAJ OSTRO≈ªNO≈öƒÜ:
1. **ChannelService jako wzorzec** - ma dzia≈ÇajƒÖcƒÖ pe≈ÇnƒÖ synchronizacjƒô Graph‚ÜîDB
2. **PowerShellCacheService P2** - nie nadpisuj istniejƒÖcych funkcji zaawansowanych
3. **Kompatybilno≈õƒá API** - kontrolery mogƒÖ wymagaƒá zmian przy dodaniu Unit of Work

---

## 8. Nastƒôpne kroki

### Etap 2: Implementacja mapowania PSObject‚ÜíEntity
- Wzoruj siƒô na `MapPsObjectToLocalChannel`
- Stw√≥rz `MapPsObjectToLocalTeam` i `MapPsObjectToLocalUser`
- Dodaj walidacjƒô biznesowƒÖ

### Etap 3: Unit of Work pattern
- Implementuj w DbContext
- Zmie≈Ñ serwisy aby nie wywo≈Çywa≈Çy SaveChanges bezpo≈õrednio
- Dodaj transakcje dla operacji bulk

### Etap 4: Migracja na ExecuteWithAutoConnectAsync
- TeamService: 5 metod do zmigowania
- UserService: 2 metody do zmigowania
- UsunƒÖƒá rƒôczne `ConnectWithAccessTokenAsync`

### Etap 5: Ujednolicenie cache
- ChannelService: zdecyduj IMemoryCache vs IPowerShellCacheService
- Dodaj hierarchiczne klucze cache (team.channels.*)

### Etap 6: Synchronizacja automatyczna
- Dodaj okresowƒÖ synchronizacjƒô w tle
- U≈ºyj istniejƒÖcych funkcji P2 cache do optymalizacji

---

## ‚ö†Ô∏è KRYTYCZNE OSTRZE≈ªENIA dla dalszych etap√≥w

1. **NIGDY nie duplikuj funkcji P2** - PowerShellCacheService ma pe≈ÇnƒÖ implementacjƒô zaawansowanych funkcji
2. **ZAWSZE u≈ºyj ChannelService jako wzorca** - jedyny serwis z pe≈ÇnƒÖ synchronizacjƒÖ Graph‚ÜîDB  
3. **PAMIƒòTAJ o funkcjach batch** - `BatchInvalidateKeys`, `GetCacheMetrics` ju≈º dzia≈ÇajƒÖ
4. **SPRAWD≈π testy** - mogƒÖ pokazaƒá oczekiwane zachowanie synchronizacji
5. **ZADBAJ o kompatybilno≈õƒá** - kontrolery mogƒÖ mieƒá w≈ÇasnƒÖ logikƒô transakcyjnƒÖ

**Nastƒôpny etap:** Implementacja mapowania PSObject‚ÜíEntity na wz√≥r ChannelService üéØ 